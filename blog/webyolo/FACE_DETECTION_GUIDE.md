# üëÅÔ∏è H∆∞·ªõng D·∫´n T√≠ch H·ª£p Face Detection Th·ª±c S·ª±

## üéØ **V·∫•n ƒê·ªÅ Hi·ªán T·∫°i:**

T·ª´ ·∫£nh ch·ª•p m√†n h√¨nh, h·ªá th·ªëng hi·ªán t·∫°i ch·ªâ l√† **m√¥ ph·ªèng** v√† ch∆∞a th·ª±c s·ª±:
- ‚ùå Nh·∫≠n di·ªán khu√¥n m·∫∑t th·ª±c t·∫ø
- ‚ùå Ph√¢n t√≠ch tr·∫°ng th√°i m·∫Øt (m·ªü/ƒë√≥ng)
- ‚ùå Ph√°t hi·ªán t∆∞ th·∫ø ƒë·∫ßu (nghi√™ng/c√∫i)
- ‚ùå ƒê√°nh gi√° ch√≠nh x√°c tr·∫°ng th√°i t·ªânh t√°o/ng·ªß g·∫≠t

## üöÄ **Gi·∫£i Ph√°p: T√≠ch H·ª£p Th∆∞ Vi·ªán Face Detection**

### **1. MediaPipe Face Mesh (Khuy·∫øn Ngh·ªã)**

MediaPipe l√† th∆∞ vi·ªán c·ªßa Google, mi·ªÖn ph√≠ v√† ch√≠nh x√°c cao:

```html
<!-- Th√™m v√†o index.html -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
```

**∆Øu ƒëi·ªÉm:**
- ‚úÖ Nh·∫≠n di·ªán 468 ƒëi·ªÉm tr√™n khu√¥n m·∫∑t
- ‚úÖ Ph√¢n t√≠ch t∆∞ th·∫ø ƒë·∫ßu ch√≠nh x√°c
- ‚úÖ Ph√°t hi·ªán m·∫Øt, m≈©i, mi·ªáng
- ‚úÖ Ho·∫°t ƒë·ªông real-time
- ‚úÖ Mi·ªÖn ph√≠ v√† open source

### **2. Face-API.js**

Th∆∞ vi·ªán d·ª±a tr√™n TensorFlow.js:

```html
<!-- Th√™m v√†o index.html -->
<script src="https://cdn.jsdelivr.net/npm/face-api.js"></script>
```

**∆Øu ƒëi·ªÉm:**
- ‚úÖ Nh·∫≠n di·ªán khu√¥n m·∫∑t v√† landmarks
- ‚úÖ Ph√¢n t√≠ch bi·ªÉu c·∫£m
- ‚úÖ Tu·ªïi v√† gi·ªõi t√≠nh
- ‚úÖ Ho·∫°t ƒë·ªông offline

### **3. OpenCV.js**

Th∆∞ vi·ªán computer vision m·∫°nh m·∫Ω:

```html
<!-- Th√™m v√†o index.html -->
<script src="https://docs.opencv.org/4.5.4/opencv.js"></script>
```

## üîß **Implementation v·ªõi MediaPipe**

### **B∆∞·ªõc 1: C√†i ƒê·∫∑t Dependencies**

```html
<!-- Trong index.html -->
<head>
    <!-- Existing code -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
</head>
```

### **B∆∞·ªõc 2: T√≠ch H·ª£p V√†o JavaScript**

```javascript
// Trong script_enhanced.js
class EnhancedDrowsinessDetector {
    constructor() {
        // Existing code...
        this.initializeFaceMesh();
    }

    async initializeFaceMesh() {
        this.faceMesh = new FaceMesh({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            }
        });

        this.faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        this.faceMesh.onResults((results) => {
            this.onFaceMeshResults(results);
        });
    }

    onFaceMeshResults(results) {
        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            const landmarks = results.multiFaceLandmarks[0];
            this.analyzeDrowsinessWithLandmarks(landmarks);
        } else {
            this.updateDetectionStats('Kh√¥ng ph√°t hi·ªán m·∫∑t', 0);
            this.clearDetectionBox();
        }
    }

    analyzeDrowsinessWithLandmarks(landmarks) {
        // Ph√¢n t√≠ch m·∫Øt
        const leftEyeOpenness = this.calculateEyeOpenness(landmarks, 'left');
        const rightEyeOpenness = this.calculateEyeOpenness(landmarks, 'right');
        const avgEyeOpenness = (leftEyeOpenness + rightEyeOpenness) / 2;

        // Ph√¢n t√≠ch t∆∞ th·∫ø ƒë·∫ßu
        const headPose = this.calculateHeadPose(landmarks);

        // ƒê√°nh gi√° tr·∫°ng th√°i
        let status = 'T·ªânh t√°o';
        let confidence = 95;
        let alertLevel = 'normal';

        // Ki·ªÉm tra m·∫Øt nh·∫Øm
        if (avgEyeOpenness < 0.3) {
            this.eyeClosedFrames++;
        } else {
            this.eyeClosedFrames = Math.max(0, this.eyeClosedFrames - 1);
        }

        // Ki·ªÉm tra ƒë·∫ßu nghi√™ng/c√∫i
        if (Math.abs(headPose.tilt) > 15 || Math.abs(headPose.pitch) > 15) {
            this.headDownFrames++;
        } else {
            this.headDownFrames = Math.max(0, this.headDownFrames - 1);
        }

        // ƒê√°nh gi√° tr·∫°ng th√°i
        if (this.eyeClosedFrames > this.alertThreshold || this.headDownFrames > this.alertThreshold) {
            status = 'Ng·ªß g·∫≠t';
            confidence = Math.min(95, 60 + Math.max(this.eyeClosedFrames, this.headDownFrames) * 2);
            alertLevel = 'sleeping';
        } else if (this.eyeClosedFrames > 5 || this.headDownFrames > 5) {
            status = 'Bu·ªìn ng·ªß';
            confidence = Math.min(85, 50 + Math.max(this.eyeClosedFrames, this.headDownFrames) * 3);
            alertLevel = 'drowsy';
        }

        // C·∫≠p nh·∫≠t UI
        this.updateDetectionStats(status, confidence);
        this.drawDetectionBoxWithLandmarks(landmarks, alertLevel, confidence);
        this.addToHistory(status, confidence);
    }

    calculateEyeOpenness(landmarks, eye) {
        // MediaPipe landmarks cho m·∫Øt
        const eyeIndices = eye === 'left' ? 
            [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398] :
            [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246];

        // T√≠nh t·ª∑ l·ªá m·ªü m·∫Øt (EAR - Eye Aspect Ratio)
        const ear = this.calculateEAR(landmarks, eyeIndices);
        return ear;
    }

    calculateEAR(landmarks, eyeIndices) {
        // T√≠nh kho·∫£ng c√°ch gi·ªØa c√°c ƒëi·ªÉm m·∫Øt
        const A = this.distance(landmarks[eyeIndices[1]], landmarks[eyeIndices[5]]);
        const B = this.distance(landmarks[eyeIndices[2]], landmarks[eyeIndices[4]]);
        const C = this.distance(landmarks[eyeIndices[0]], landmarks[eyeIndices[3]]);

        // EAR = (A + B) / (2.0 * C)
        return (A + B) / (2.0 * C);
    }

    calculateHeadPose(landmarks) {
        // T√≠nh t∆∞ th·∫ø ƒë·∫ßu d·ª±a tr√™n landmarks
        const nose = landmarks[1];
        const leftEye = landmarks[33];
        const rightEye = landmarks[263];

        // T√≠nh g√≥c nghi√™ng (roll)
        const eyeCenter = {
            x: (leftEye.x + rightEye.x) / 2,
            y: (leftEye.y + rightEye.y) / 2
        };
        const tilt = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x) * 180 / Math.PI;

        // T√≠nh g√≥c c√∫i (pitch) - simplified
        const pitch = (nose.y - eyeCenter.y) * 100;

        return { tilt, pitch, roll: 0 };
    }

    distance(point1, point2) {
        return Math.sqrt(
            Math.pow(point1.x - point2.x, 2) + 
            Math.pow(point1.y - point2.y, 2)
        );
    }

    drawDetectionBoxWithLandmarks(landmarks, alertLevel, confidence) {
        if (!this.detectionOverlay) return;

        this.detectionOverlay.innerHTML = '';

        // V·∫Ω khung khu√¥n m·∫∑t
        const faceBox = this.createFaceBox(landmarks, alertLevel, confidence);
        this.detectionOverlay.appendChild(faceBox);

        // V·∫Ω landmarks
        this.drawLandmarks(landmarks);

        // V·∫Ω th√¥ng tin chi ti·∫øt
        this.drawDetailedInfoWithLandmarks(landmarks, alertLevel, confidence);
    }

    createFaceBox(landmarks, alertLevel, confidence) {
        // T√≠nh bounding box t·ª´ landmarks
        const xs = landmarks.map(p => p.x);
        const ys = landmarks.map(p => p.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);

        const faceBox = document.createElement('div');
        faceBox.className = `detection-box ${alertLevel}`;
        faceBox.style.cssText = `
            position: absolute;
            border: 3px solid ${alertLevel === 'sleeping' ? '#ff0000' : alertLevel === 'drowsy' ? '#ffaa00' : '#00ff00'};
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
            left: ${minX * 100}%;
            top: ${minY * 100}%;
            width: ${(maxX - minX) * 100}%;
            height: ${(maxY - minY) * 100}%;
        `;

        const label = document.createElement('div');
        label.textContent = `${alertLevel.toUpperCase()} (${confidence}%)`;
        label.style.cssText = `
            position: absolute;
            top: -25px;
            left: 0;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        `;

        faceBox.appendChild(label);
        return faceBox;
    }

    drawLandmarks(landmarks) {
        // V·∫Ω c√°c ƒëi·ªÉm landmarks quan tr·ªçng
        const importantLandmarks = [1, 33, 133, 362, 263, 61, 291]; // Nose, eyes, mouth
        importantLandmarks.forEach(index => {
            const point = landmarks[index];
            const dot = document.createElement('div');
            dot.style.cssText = `
                position: absolute;
                left: ${point.x * 100}%;
                top: ${point.y * 100}%;
                width: 4px;
                height: 4px;
                background: #00ff00;
                border-radius: 50%;
                transform: translate(-50%, -50%);
            `;
            this.detectionOverlay.appendChild(dot);
        });
    }

    drawDetailedInfoWithLandmarks(landmarks, alertLevel, confidence) {
        const infoBox = document.createElement('div');
        infoBox.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
            max-width: 200px;
        `;

        const leftEyeOpenness = this.calculateEyeOpenness(landmarks, 'left');
        const rightEyeOpenness = this.calculateEyeOpenness(landmarks, 'right');
        const headPose = this.calculateHeadPose(landmarks);

        infoBox.innerHTML = `
            <div><strong>Tr·∫°ng th√°i:</strong> ${alertLevel}</div>
            <div><strong>ƒê·ªô tin c·∫≠y:</strong> ${confidence}%</div>
            <div><strong>M·∫Øt tr√°i:</strong> ${(leftEyeOpenness * 100).toFixed(1)}%</div>
            <div><strong>M·∫Øt ph·∫£i:</strong> ${(rightEyeOpenness * 100).toFixed(1)}%</div>
            <div><strong>ƒê·∫ßu nghi√™ng:</strong> ${headPose.tilt.toFixed(1)}¬∞</div>
            <div><strong>M·∫Øt nh·∫Øm:</strong> ${this.eyeClosedFrames} frames</div>
            <div><strong>ƒê·∫ßu nghi√™ng:</strong> ${this.headDownFrames} frames</div>
        `;

        this.detectionOverlay.appendChild(infoBox);
    }
}
```

### **B∆∞·ªõc 3: C·∫≠p Nh·∫≠t Detection Loop**

```javascript
detectionLoop() {
    if (!this.isRunning) return;
    
    this.frameCount++;
    this.updateFPS();
    
    // S·ª≠ d·ª•ng MediaPipe thay v√¨ m√¥ ph·ªèng
    if (this.webcam && this.webcam.videoWidth > 0) {
        this.faceMesh.send({image: this.webcam});
    }
    
    requestAnimationFrame(() => this.detectionLoop());
}
```

## üìä **So S√°nh Hi·ªáu Su·∫•t:**

| T√≠nh NƒÉng | M√¥ Ph·ªèng | MediaPipe | Face-API.js |
|-----------|----------|-----------|-------------|
| **ƒê·ªô Ch√≠nh X√°c** | ‚ùå 0% | ‚úÖ 95%+ | ‚úÖ 90%+ |
| **Real-time** | ‚úÖ C√≥ | ‚úÖ C√≥ | ‚ö†Ô∏è Ch·∫≠m h∆°n |
| **Face Detection** | ‚ùå Kh√¥ng | ‚úÖ C√≥ | ‚úÖ C√≥ |
| **Eye Tracking** | ‚ùå Kh√¥ng | ‚úÖ C√≥ | ‚úÖ C√≥ |
| **Head Pose** | ‚ùå Kh√¥ng | ‚úÖ C√≥ | ‚ö†Ô∏è H·∫°n ch·∫ø |
| **Setup** | ‚úÖ D·ªÖ | ‚ö†Ô∏è Trung b√¨nh | ‚ö†Ô∏è Ph·ª©c t·∫°p |

## üéØ **K·∫øt Qu·∫£ Mong ƒê·ª£i:**

### **Tr∆∞·ªõc khi t√≠ch h·ª£p:**
- ‚ùå "NORMAL (95%)" d√π c√≥ 2 ng∆∞·ªùi trong khung h√¨nh
- ‚ùå Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c khu√¥n m·∫∑t th·ª±c t·∫ø
- ‚ùå Ph√¢n t√≠ch gi·∫£ l·∫≠p

### **Sau khi t√≠ch h·ª£p MediaPipe:**
- ‚úÖ Nh·∫≠n di·ªán ch√≠nh x√°c khu√¥n m·∫∑t
- ‚úÖ Ph√¢n t√≠ch ƒë·ªô m·ªü m·∫Øt th·ª±c t·∫ø
- ‚úÖ Ph√°t hi·ªán t∆∞ th·∫ø ƒë·∫ßu
- ‚úÖ ƒê√°nh gi√° tr·∫°ng th√°i ch√≠nh x√°c
- ‚úÖ Hi·ªÉn th·ªã landmarks v√† th√¥ng tin chi ti·∫øt

## üöÄ **C√°ch Tri·ªÉn Khai:**

1. **Th√™m MediaPipe scripts v√†o `index.html`**
2. **Thay th·∫ø `simulateDetection()` b·∫±ng MediaPipe implementation**
3. **Test v·ªõi webcam th·ª±c t·∫ø**
4. **ƒêi·ªÅu ch·ªânh ng∆∞·ª°ng ph√°t hi·ªán**

## üí° **L∆∞u √ù:**

- **Performance**: MediaPipe y√™u c·∫ßu GPU ƒë·ªÉ ho·∫°t ƒë·ªông t·ªët nh·∫•t
- **Lighting**: √Ånh s√°ng t·ªët gi√∫p tƒÉng ƒë·ªô ch√≠nh x√°c
- **Distance**: Kho·∫£ng c√°ch 50-100cm t·ª´ camera l√† t·ªëi ∆∞u
- **Training**: C√≥ th·ªÉ fine-tune cho ƒëi·ªÅu ki·ªán c·ª• th·ªÉ

---

**K·∫øt lu·∫≠n**: ƒê·ªÉ c√≥ h·ªá th·ªëng ph√°t hi·ªán ng·ªß g·∫≠t th·ª±c s·ª±, c·∫ßn t√≠ch h·ª£p MediaPipe ho·∫∑c Face-API.js thay v√¨ ch·ªâ m√¥ ph·ªèng! üéØ
